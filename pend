#!/usr/bin/python3
import re
import argparse
from datetime import datetime
from sys import exit
from enum import Enum

VERSION = r"0.0.7"

class State(Enum):
    PENDING = 1
    DISCARDED = 2
    COMPLETED = 3

class TodoStore:
    def __init__(self, master: tuple[2]):
        self.arr = []
        self.arr.append(master)

    def add(self, slave: tuple[2]):
        self.arr.append(slave)

def is_slave(s: str):
    st = s[0]
    if st == ' ' or st == '\t':
        return True
    return False

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-a", "--all", default = False, action = "store_true", help = "print all tasks")
    parser.add_argument("-i", "--input", default = "todo.txt", help = "default: todo.txt, path to the todo file", metavar = "file")
    parser.add_argument("-p", "--pending", default = False, action = "store_true", help = "only show pending tasks")
    parser.add_argument("-v", "--version", default = False, action = "store_true", help = "print current version")
    parser.add_argument("-d", "--date", default = False, action = "store_true", help = "print dates")
    parser.add_argument("-c", "--complete", default = False, action = "store_true", help = "only show completed tasks")
    parser.add_argument("--discard", default = False, action = "store_true", help = "only show discarded tasks")
    parser.add_argument("--indent", default="  ", help = "indentation string, default is 2 spaces")

    args = parser.parse_args()

    if args.version:
        print(f"pending version {VERSION}")
        exit(0)

    todo_file = args.input
    print_today = not args.all
    print_date = args.date
    only_pending = args.pending
    only_complete = args.complete
    only_discard = args.discard
    indent = args.indent

    f = None
    try:
        f = open(todo_file, "r")
    except:
        print(f"failed to open todo file \"{todo_file}\"")
        exit(1)

    date_pat = re.compile(r"^([0-9]{4,5}-[0-9]{1,2}-[0-9]{1,2}).*$")
    comp_pre = '[OK]'
    half_comp_pre = '[O]'
    discard_pre = '[DISCARD]'

    # [ TodoStore ]
    pending = []
    completed = []
    discarded = []

    date_format = "%Y-%m-%d"

    __today = datetime.today()
    today = datetime(__today.year, __today.month, __today.day)
    date_tmp = today

    lines = f.readlines()
    f.close()

    # temporary storages
    todo_store = None
    todo_store_t = None
    append = ""

    collect_completed = not (only_pending or only_discard)
    collect_discarded = not (only_pending or only_complete)
    collect_pending = not (only_complete or only_discard)

    def store_todo(todo_store: TodoStore, state: State):
        if todo_store is None:
            raise RuntimeError("This todo store is empty")

        if state == State.PENDING:
            pending.append(todo_store)
        elif state == State.COMPLETED:
            completed.append(todo_store)
        else:
            discarded.append(todo_store)

    for line in lines:
        line = line.strip("\n\r")

        first_hash = line.find('#')
        if first_hash != -1:
            line = line[:first_hash]

        if len(line) == 0 or line.isspace():
            continue

        # get the date and go to the next line
        if date_match := date_pat.match(line):
            date_tmp = datetime.strptime(date_match.group(1), date_format)
        else:
            # only print today's todo items, skip
            # why continue but not break: today's date can come later than the passed days if
            # user is not careful
            if print_today and date_tmp != today:
                continue

            # multi-line
            if line[-1] == '\\':
                append += line[:-1] # exclude the backslash
                continue

            # first non-backslash-ended item: build the result
            if len(append) != 0:
                line = append + line
                append = ""

            if line.startswith(comp_pre):
                if collect_completed:
                    if is_slave(line) and todo_store:
                        todo_store.add((date_tmp, line))
                    else:
                        # the previous TodoStore ends
                        if todo_store:
                            store_todo(todo_store, todo_store_t)
                        todo_store = TodoStore((date_tmp, line))
                        todo_store_t = State.COMPLETED
            elif line.startswith(discard_pre):
                if collect_discarded:
                    if is_slave(line) and todo_store:
                        todo_store.add((date_tmp, line))
                    else:
                        if todo_store:
                            store_todo(todo_store, todo_store_t)
                        todo_store = TodoStore((date_tmp, line))
                        todo_store_t = State.DISCARDED
            elif collect_pending:
                if is_slave(line) and todo_store:
                    todo_store.add((date_tmp, line))
                else:
                    if todo_store:
                        store_todo(todo_store, todo_store_t)
                    todo_store = TodoStore((date_tmp, line))
                    todo_store_t = State.PENDING

    # the last todo store
    if todo_store:
        store_todo(todo_store, todo_store_t)

    # avoid extra newlines
    if len(pending) == 0 and len(completed) == 0 and len(discarded) == 0:
        print("No todo items found")
        return

    # pending: Master - Slave
    # Todo Master
    #   Todo Slave 1
    #   Todo Slave 2
    #   Todo Slave 3

    # pending (not completed)
    if len(pending) > 0:
        print()
    print("\033[0;31m", end="")
    for todo_store in pending:
        for task in todo_store.arr:
            if print_today and task[0] < today:
                break

            non_space_i = 0
            content_tmp = task[1]
            for i in range(len(content_tmp)):
                c = content_tmp[i]
                if c != ' ' and c != '\t':
                    non_space_i = i
                    break

            ws = content_tmp[:non_space_i]
            content = content_tmp[non_space_i:]

            s = ""
            if print_date:
                s += f"{task[0].strftime(date_format)} "

            s += ws
            if content.startswith(comp_pre):
                s += "\033[0;32m"
                s += content
                s += "\033[0;0m"
            elif content.startswith(discard_pre):
                s += "\033[0;33m"
                s += content
                s += "\033[0;0m"
            elif content.startswith(half_comp_pre):
                s += "\033[0;32m" + "[O]" + "\033[0;31m" + content[3:]
            else:
                s += "\033[0;31m"
                s += content
                s += "\033[0;0m"
            print(indent, s, sep="")
    print("\033[0;0m", end="")

    # completed
    if len(completed) > 0:
        print()
    print("\033[0;32m", end="")
    for todo_store in completed:
        for task in todo_store.arr:
            if print_today and task[0] < today:
                break
            s = ""
            if print_date:
                s += f"{task[0].strftime(date_format)} "
            s += f"{task[1]}"
            print(indent, s, sep="")
    print("\033[0;0m", end="")

    # discarded
    if len(discarded) > 0:
        print()
    print("\033[0;33m", end="")
    for todo_store in discarded:
        for task in todo_store.arr:
            if print_today and task[0] < today:
                break
            s = ""
            if print_date:
                s += f"{task[0].strftime(date_format)} "
            s += f"{task[1]}"
            print(indent, s, sep="")
    print("\033[0;0m", end="")
    print()

if __name__ == "__main__":
    main()
