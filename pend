#!/usr/bin/python3
import re
import argparse
from datetime import datetime
from sys import exit

VERSION = r"0.0.6"

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-a", "--all", default = False, action = "store_true", help = "print all tasks")
    parser.add_argument("-i", "--input", default = "todo.txt", help = "default: todo.txt, path to the todo file", metavar = "file")
    parser.add_argument("-p", "--pending", default = False, action = "store_true", help = "only show pending tasks")
    parser.add_argument("-v", "--version", default = False, action = "store_true", help = "print current version")
    parser.add_argument("-d", "--date", default = False, action = "store_true", help = "print dates")
    parser.add_argument("-c", "--complete", default = False, action = "store_true", help = "only show completed tasks")
    parser.add_argument("--discard", default = False, action = "store_true", help = "only show discarded tasks")

    args = parser.parse_args()

    if args.version:
        print(f"pending version {VERSION}")
        exit(0)

    todo_file = args.input
    print_today = not args.all
    print_date = args.date
    only_pending = args.pending
    only_complete = args.complete
    only_discard = args.discard

    f = None
    try:
        f = open(todo_file, "r")
    except:
        print(f"failed to open todo file \"{todo_file}\"")
        exit(1)

    date_pat = re.compile(r"^([0-9]{4,5}-[0-9]{1,2}-[0-9]{1,2}).*$")
    comp_pre = '[OK]'
    half_comp_pre = '[O]'
    discard_pre = '[DISCARD]'

    # (date, time)
    pending = []
    completed = []
    discarded = []

    date_format = "%Y-%m-%d"

    __today = datetime.today()
    today = datetime(__today.year, __today.month, __today.day)
    date_tmp = today

    lines = f.readlines()
    f.close()

    append = ""

    collect_completed = not (only_pending or only_discard)
    collect_discarded = not (only_pending or only_complete)
    collect_pending = not (only_complete or only_discard)

    for line in lines:
        line = line.strip("\n\r")

        first_hash = line.find('#')
        if first_hash != -1:
            line = line[:first_hash]

        if len(line) == 0 or line.isspace():
            continue

        # get the date and go to the next line
        if date_match := date_pat.match(line):
            date_tmp = datetime.strptime(date_match.group(1), date_format)
        else:
            # only print today's todo items, skip
            # why continue but not break: today's date can come later than the passed days if
            # user is not careful
            if print_today and date_tmp != today:
                continue

            # multi-line
            if line[-1] == '\\':
                append += line[:-1] # exclude the backslash
                continue

            # first non-backslash-ended item: build the result
            if len(append) != 0:
                line = append + line
                append = ""

            if line.startswith(comp_pre):
                if collect_completed:
                    completed.append((date_tmp, line))
            elif line.startswith(discard_pre):
                if collect_discarded:
                    discarded.append((date_tmp, line))
            elif collect_pending:
                pending.append((date_tmp, line))

    # avoid extra newlines
    if len(pending) == 0 and len(completed) == 0 and len(discarded) == 0:
        print("No todo items found")
        return

    # pending (not completed)
    if len(pending) > 0:
        print()
    print("\033[0;31m", end="")
    for task in pending:
        if print_today and task[0] < today:
            break
        is_half_comp = task[1].startswith(half_comp_pre)
        s = "  "
        if print_date:
            s += f"{task[0].strftime(date_format)} "
        if is_half_comp:
            s += "\033[0;32m" + "[O]" + "\033[0;31m" + task[1][3:]
        else:
            s += task[1]
        print(s)
    print("\033[0;0m", end="")

    # completed
    if len(completed) > 0:
        print()
    print("\033[0;32m", end="")
    for task in completed:
        if print_today and task[0] < today:
            break
        s = "  "
        if print_date:
            s += f"{task[0].strftime(date_format)} "
        s += f"{task[1]}"
        print(s)
    print("\033[0;0m", end="")

    # discarded
    if len(discarded) > 0:
        print()
    print("\033[0;33m", end="")
    for task in discarded:
        if print_today and task[0] < today:
            break
        s = "  "
        if print_date:
            s += f"{task[0].strftime(date_format)} "
        s += f"{task[1]}"
        print(s)
    print("\033[0;0m", end="")
    print()

if __name__ == "__main__":
    main()
