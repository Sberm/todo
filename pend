#!/usr/bin/python3
import re
import argparse
from datetime import datetime
from sys import exit

VERSION = r"0.0.6"

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-a", "--all", default = False, action = "store_true", help = "print all tasks")
    parser.add_argument("-i", "--input", default = "todo.txt", help = "default: todo.txt, path to the todo file", metavar = "file")
    parser.add_argument("-p", "--pending", default = False, action = "store_true", help = "only show pending tasks")
    parser.add_argument("-v", "--version", default = False, action = "store_true", help = "print current version")
    parser.add_argument("-d", "--date", default = False, action = "store_true", help = "print dates")
    parser.add_argument("-c", "--complete", default = False, action = "store_true", help = "only show completed tasks")

    args = parser.parse_args()

    if args.version:
        print(f"pending version {VERSION}")
        exit(0)

    todo_file = args.input
    only_pending = args.pending
    print_today = not args.all
    print_date = args.date
    only_complete = args.complete

    f = None
    try:
        f = open(todo_file, "r")
    except:
        print(f"failed to open todo file \"{todo_file}\"")
        exit(1)

    date_pat = re.compile(r"^([0-9]{4,5}-[0-9]{1,2}-[0-9]{1,2}).*$")
    comp_pre = '[OK]'
    half_comp_pre = '[O]'

    # (date, time)
    pending = []
    completed = []

    date_format = "%Y-%m-%d"

    __today = datetime.today()
    today = datetime(__today.year, __today.month, __today.day)
    date_tmp = today

    lines = f.readlines()
    f.close()

    append = ""

    for line in lines:
        line.lstrip('\t ')
        line.strip("\n\r")

        first_hash = line.find('#')
        line = line[:first_hash]

        if len(line) == 0 or line.isspace():
            continue

        # get the date and go to the next line
        if date_match := date_pat.match(line):
            date_tmp = datetime.strptime(date_match.group(1), date_format)
        else:
            # only print today's todo items, skip
            # why continue but not break: today's date can come later than the passed days if
            # user is not careful
            if print_today and date_tmp != today:
                continue

            # multi-line
            if line[-1] == '\\':
                append += line[:-1] # exclude the backslash
                continue

            # first non-backslash-ended item: build the result
            if len(append) != 0:
                line = append + line
                append = ""

            if line.startswith(comp_pre):
                if not only_pending:
                    completed.append((date_tmp, line))
            else:
                if not only_complete:
                    pending.append((date_tmp, line))

    # avoid extra newlines
    if len(pending) == 0 and len(completed) == 0:
        print("No todo items found")
        return

    # pending (not completed)
    print()
    print("\033[0;31m", end="")
    for task in pending:
        if print_today and task[0] < today:
            break
        is_half_comp = task[1].startswith(half_comp_pre)
        s = "  "
        if print_date:
            s += f"{task[0].strftime(date_format)} "
        if is_half_comp:
            s += "\033[0;32m" + "[O]" + "\033[0;31m" + task[1][3:]
        else:
            s += task[1]
        print(s)
    print("\033[0;0m", end="")

    # completed
    printed = False
    print("\033[0;32m", end="")
    for task in completed:
        if print_today and task[0] < today:
            break

        # if any completed tasks need printing, print newline first
        if not printed:
            print()

        printed = True
        s = "  "
        if print_date:
            s += f"{task[0].strftime(date_format)} "
        s += f"{task[1]}"
        print(s)
    print("\033[0;0m", end="")
    print()

if __name__ == "__main__":
    main()
