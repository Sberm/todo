#!/usr/bin/python3
import re
import argparse
from datetime import datetime

def main():
	parser = argparse.ArgumentParser()
	parser.add_argument("-a", "--all", default = False, action="store_true", help = "print all todo items")
	parser.add_argument("-i", "--input", default = "todo.txt", help = "default: todo.txt, path to the todo file", metavar = "file")
	args = parser.parse_args()

	print_today = not args.all
	todo_file = args.input

	with open(todo_file, "r") as f:
		# regex for date (TODO: Add length restrictions, for example [0-9]{4} or sth)
		date_neg = re.compile("[0-9]+-[0-9]+-[0-9]+")
		completion_neg = re.compile("^\\[OK]")

		# (date, time)
		pending = []
		completed = []

		date_format = "%Y-%m-%d"
		line_max = 45

		__today = datetime.today()
		today = datetime(__today.year, __today.month, __today.day)
		date_tmp = today
		lines = f.readlines()

		for line in lines:
			if line.isspace():
				continue

			line = line.strip()

			# get the date and go to the next line
			if date_neg.search(line):
				date_tmp = datetime.strptime(line, date_format)
				continue

			if print_today and date_tmp != today:
				continue

			if completion_neg.search(line):
				completed.append((date_tmp, line))
			else:
				pending.append((date_tmp, line))

		# pending (not completed)
		print()
		print("\033[0;31m", end="")
		for task in pending:
			if print_today and task[0] < today:
				break
			print("  ", task[0].strftime(date_format), " ", task[1][:line_max], sep="")
		print("\033[0;0m", end="")

		# completed
		printed = False
		print("\033[0;32m", end="")
		for task in completed:
			if print_today and task[0] < today:
				break

			# if any completed tasks need printing, print newline first
			if not printed:
				print()

			printed = True
			print("  ", task[0].strftime(date_format), " ", task[1][:line_max], sep="")
		print("\033[0;0m", end="")

		print()

if __name__ == "__main__":
	main()
